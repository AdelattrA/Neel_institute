from datetime import time
import os
from quantumstring.field import OneSpaceField

from quantumstring.simulation import CenterFixed, FreeString, RingString, Simulation, Cavity
from quantumstring.edge import ExcitatorSinAbsorber, MirrorEdge, ExcitatorSin, AbsorberEdge
from quantumstring.particle import Particles, Particle
from quantumstring.process import PostProcess

import numpy as np
from matplotlib import pyplot as plt
from scipy import fftpack as fft

mypath = os.path.dirname(os.path.abspath(__file__))
mypath = "C:\\Users\\...\\quantum-string-master\\quantum-string-master\\output" #BIEN RENSEIGNER LE BON PATH CONTENANT LE DOSSIER QUANTUM-STRING-MASTER

duration = 2.0 # [s]
space_steps = 2047
length = 1.94 # [m]
density = 0.013 # [kg/m]

c = 295 #Bien recopier la célérité expérimentale
dx = length/space_steps
dt = dx/c


frequencies = np.array([i for i in range(20, 100, 5)]).astype(float) # excitator frequencies we use for the simulations
pulsations = 2*np.pi*frequencies

# caracteristics for the mass
pmass = 0.0317 # [kg]
pstiff = 1154 # [N/m] 
f_p = (np.sqrt(pstiff/pmass))/(2*np.pi) #30.37
pomega = 2*np.pi*f_p #Bien recopier la fréquence de la particule [Hz]

t_theory_list = []
t_exp_list = []

transmission_value = lambda a: 1/(1 - complex(0, 1)/a) # theoretical expression of 't' as a function of α

for omega in pulsations:
    # we create the edges
    examp = 0.05 # [m]
    right = AbsorberEdge()
    left = ExcitatorSinAbsorber(dt, examp, omega)
    k = omega/c
    excitator = lambda x, t: examp*np.sin(k*x - omega*t) # we define the field generated by the excitator, as a function of x and t   

    ### THEORY:
    alpha = 2*omega*density*c/(pstiff - pmass*omega**2)
    t_theory = transmission_value(alpha)
    t_theory_list.append(t_theory)

pulsation_spectrum = np.linspace(1.0, 1000.0, 200)
alpha_spectrum = 2*density*c*pulsation_spectrum/(pstiff - pmass*pulsation_spectrum**2)
t_spectrum = transmission_value(alpha_spectrum)
mod_sqr_spectrum = t_spectrum*t_spectrum.conjugate()
angle_spectrum = np.angle(t_spectrum) 

nb_pts = len(t_theory_list)
cmap = plt.cm.get_cmap("plasma", nb_pts)

### PLOT DESIGN:
### we make the layout for the graphs
fig = plt.figure()
ax_mod = fig.add_subplot()
ax_mod.set_title("Transmission Curve")
ax_mod.set_xlabel("$\omega / \omega_0$")
ax_mod.set_ylabel("$|t|$")
ax_mod.grid()

def Transmission(a,b):
    c = float(b)/float(a)
    return c

# Realisation du balayage en fréquence

f_0 = f_p
f_0=float(f_0)

data = [
    [20,9.01,4.05],
    [22,9.98,4.77],
    [23,10.82,5.48],
    [24,11.63,6.01],
    [25,11.9,7.8],
    [26,11.6,11.6],
    [27,12.8,11.1],
    [28,12.9,4.1],
    [30,14.1,2.4],
    [40,13.6,1.3],
    [50,12.2,1.1],
]


Resultats = []

for i in range(len(data)):
    f= data[i][0]
    f=float(f)
    a_0 = data[i][1]  
    a_0 = float(a_0)
    a_1 = data[i][2]  
    a_1 = float(a_1)
    tau = Transmission(a_0,a_1)
    Resultats.append([f/f_0,tau])


# we plot the theoretical values
ax_mod.plot(pulsation_spectrum/pomega, mod_sqr_spectrum, "k-")

for the,count, omega in zip(t_theory_list,  range(0, nb_pts), pulsations):
    label = label="{:.0f}Hz".format(omega*0.5/np.pi)
    ax_mod.plot(omega/pomega, np.abs(the), linewidth=1)
    if count == nb_pts-1:
        ax_mod.plot(omega/pomega, np.abs(the), linewidth=1, label = "Modèle théorique")
        


    #Affichage du résultat
for j in range(len(Resultats)) :    
    ax_mod.plot(Resultats[j][0], Resultats[j][1], color = "#889717", marker = "x", markersize=3)
    if j == len(Resultats)-1:
        ax_mod.plot(Resultats[j][0], Resultats[j][1], color = "#889717", marker = "x", markersize=3, label = "Données expérimentales")

plt.legend()
plt.show()


